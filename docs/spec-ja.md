# CSVT (CSV with Types) 仕様書

**バージョン:** 0.1.0
**最終更新日:** 2025-04-05

## 変更履歴 (Change Log)

- **v0.1.0 (2025-04-05):** 初版発行

## 目次

- [1. はじめに](#1-はじめに)
  - [1.1. 概要](#11-概要)
  - [1.2. 背景と目的](#12-背景と目的)
- [2. 基本仕様](#2-基本仕様)
  - [2.1. ファイル構造](#21-ファイル構造)
  - [2.2. ヘッダー行フォーマット](#22-ヘッダー行フォーマット)
  - [2.3. データ行](#23-データ行)
- [3. データ型定義](#3-データ型定義)
  - [3.1. 基本型](#31-基本型)
    - [3.1.1. `string`](#311-string)
    - [3.1.2. `number`](#312-number)
    - [3.1.3. `bool`](#313-bool)
    - [3.1.4. `date`](#314-date)
    - [3.1.5. `datetime`](#315-datetime)
  - [3.2. 複合型](#32-複合型)
    - [3.2.1. `array`](#321-array)
    - [3.2.2. `object`](#322-object)
  - [3.3. 非Null制約 (`!`)](#33-非null制約-)
- [4. 値の表現と制約](#4-値の表現と制約)
  - [4.1. NULL 値の表現](#41-null-値の表現)
  - [4.2. データのエスケープ](#42-データのエスケープ)
  - [4.3. データ型と値の整合性](#43-データ型と値の整合性)
    - [4.3.1. 型不一致の判断基準 (例)](#431-型不一致の判断基準-例)
    - [4.3.2. 非Null制約違反](#432-非null制約違反)
    - [4.3.3. 違反時の処理](#433-違反時の処理)
- [5. セキュリティに関する考慮事項](#5-セキュリティに関する考慮事項)
- [Appendix A: CSVT ファイルの例](#appendix-a-csvt-ファイルの例)
  - [A.1. 基本的な例](#a1-基本的な例)
  - [A.2. 複合型とエスケープを含む例](#a2-複合型とエスケープを含む例)
  - [A.3. 非Null制約の例](#a3-非null制約の例)
  - [A.4. 特殊文字を含むカラム名の例](#a4-特殊文字を含むカラム名の例)
- [変更履歴](#変更履歴-change-log)

---

## 1. はじめに

### 1.1. 概要

CSVT (CSV with Types) は、標準的な CSV (Comma-Separated Values) フォーマットを拡張し、ヘッダー行に各カラムのデータ型情報を含めることを可能にする仕様です。本仕様は、CSVT フォーマットの構造、データ型、および関連する規約を定義します。

### 1.2. 背景と目的

標準的な CSV は、そのシンプルさから広く普及していますが、各カラムが表現するデータの種類（文字列、数値、日付等）をファイル自体から判断することが困難です。この曖昧さは、データの解釈や処理において誤りを引き起こす可能性があります。

CSVT は、ヘッダー行にデータ型情報を明示的に記述する規約を導入することで、CSV ファイルの自己記述性を高め、データ利用時における解釈の明確性を向上させることを目的とします。

## 2. 基本仕様

### 2.1. ファイル構造

*   **エンコーディング:** UTF-8 を強く推奨します (MUST)。
*   **区切り文字:** カンマ (`,`) を標準の区切り文字とします (MUST)。
*   **改行コード:** LF (`\\n`) または CRLF (`\\r\\n`) を使用します (MUST)。
*   **最初の行:** ヘッダー行として定義され、カラム名と型情報を指定します (MUST)。詳細は [2.2. ヘッダー行フォーマット](#22-ヘッダー行フォーマット) を参照してください。
*   **2行目以降:** データ行として定義され、ヘッダーで定義された順序と型に従う必要があります (MUST)。詳細は [2.3. データ行](#23-データ行) を参照してください。

### 2.2. ヘッダー行フォーマット

ヘッダー行は、ファイルの最初の行であり、各カラムの名前とデータ型を定義します。

*   各ヘッダーフィールドは `カラム名:型名` の形式で記述します (MUST)。
*   **カラム名:**
    *   フィールドの名前を表します。
    *   区切り文字 (`,`)、改行 (`\\n`, `\\r\\n`)、またはコロン (`:`) を含む場合は、フィールド全体をダブルクォート (`"`) で囲む必要があります (MUST)。囲まれた内部のダブルクォートは `""` にエスケープします。例: `"order:date":date`。
*   **区切り文字 (`:`)**:
    *   カラム名と型名を区切る予約文字です (MUST)。
*   **型名:**
    *   [3. データ型定義](#3-データ型定義) で定義される型名のいずれかです (MUST)。
    *   型名は大文字・小文字を区別しませんが、小文字での記述を推奨します (SHOULD)。
    *   型指定が省略された場合、デフォルトで `string` 型として扱われます (MUST)。例: `userId` は `userId:string` と等価です。

### 2.3. データ行

ファイルの2行目以降はデータ行です。

*   各データ行は、ヘッダー行で定義されたカラムと同じ数のフィールドを持つ必要があります (MUST)。
*   各フィールドの値は、ヘッダーで定義された対応するカラムの型および制約 ([3. データ型定義](#3-データ型定義), [4. 値の表現と制約](#4-値の表現と制約)) に準拠する必要があります (MUST)。
*   フィールド値のエスケープ規則については、[4.2. データのエスケープ](#42-データのエスケープ) を参照してください。

## 3. データ型定義

以下のデータ型を定義します。

### 3.1. 基本型

#### 3.1.1. `string`

*   任意の文字列データを表します。
*   ヘッダーで型指定が省略された場合のデフォルト型です。

#### 3.1.2. `number`

*   整数および浮動小数点数を表します (JSON の `number` 型に相当)。
*   例: `10`, `-5`, `0`, `3.14`, `-0.5`, `1.0e-3`。

#### 3.1.3. `bool`

*   論理的な真偽値を表します。
*   値の表現:
    *   `true` または `false` (小文字) の文字列リテラルを強く推奨します (SHOULD) (JSON の `boolean` 型リテラルに相当)。
    *   パーサーは、実装によっては他の表現 (`TRUE`, `FALSE`, `1`, `0` など) を解釈しても構いません (MAY)。しかし、CSVT ファイルを生成する際は `true` または `false` を使用すべきです (SHOULD)。

#### 3.1.4. `date`

*   特定の日付を表します。
*   値の表現: ISO 8601 形式 (`YYYY-MM-DD`) の文字列を強く推奨します (SHOULD)。例: `2023-10-26`。

#### 3.1.5. `datetime`

*   特定の日時と、オプションでタイムゾーンを表します。
*   値の表現: ISO 8601 形式の文字列を強く推奨します (SHOULD)。
    *   例: `2023-10-26T10:30:00Z`, `2023-10-26T19:30:00+09:00`。

### 3.2. 複合型

#### 3.2.1. `array`

*   JSON 配列として解釈されるデータを格納します。
*   値の表現:
    *   CSV セル内では、JavaScript/JSON の配列を JSON 文字列としてシリアライズし、その結果の文字列に対して必要に応じて [4.2. データのエスケープ](#42-データのエスケープ) で定義される CSV エスケープ処理を施したものを値とします (MUST)。
    *   例: 元の配列 `[1, "item", true]` は、JSON 文字列 `"\[1,\\"item\\",true]"` となり、CSV セル内では `"[1,\\\"item\\\",true]"` と表現されます。 (注: マークダウン内でのエスケープ表示のためバックスラッシュが多重に見える場合があります)

#### 3.2.2. `object`

*   JSON オブジェクトとして解釈されるデータを格納します。
*   値の表現:
    *   CSV セル内では、JavaScript/JSON のオブジェクトを JSON 文字列としてシリアライズし、その結果の文字列に対して必要に応じて [4.2. データのエスケープ](#42-データのエスケープ) で定義される CSV エスケープ処理を施したものを値とします (MUST)。
    *   例: 元のオブジェクト `{"key": "value", "num": 1}` は、JSON 文字列 `"{\\"key\\":\\"value\\",\\"num\\":1}"` となり、CSV セル内では `"{""key"":""value"",""num"":1}"` と表現されます。 (注: マークダウン内でのエスケープ表示のためバックスラッシュが多重に見える場合があります)

### 3.3. 非Null制約 (`!`)

*   カラムの値が必須であり、NULL (または空文字列) であってはならないことを示すために、型名の末尾にエクスクラメーションマーク (`!`) を付加します (MUST)。
*   例: `string!`, `number!`, `bool!`, `date!`, `datetime!`, `array!`, `object!`。
*   `!` が付加されたカラムでは、データ行の対応するフィールドが空 (`""`) であってはなりません (MUST)。詳細は [4.3.2. 非Null制約違反](#432-非null制約違反) を参照してください。

## 4. 値の表現と制約

### 4.1. NULL 値の表現

*   デフォルトでは、すべてのカラムが NULL 値 (値が存在しないこと) を許容します。
*   データ行において NULL を表現するには、対応するフィールドを **空** (`""`) にします (MUST)。
    *   例: `value1,,value3` の場合、2番目のフィールドは NULL を表します。
*   型名に非Null制約 (`!`) が付加されていない限り、パーサーは空フィールドを `null` として解釈すべきです (SHOULD)。

### 4.2. データのエスケープ

データフィールドの値に関して、以下のエスケープルールを適用します (MUST)。これは [RFC 4180](https://tools.ietf.org/html/rfc4180) で定義されている標準的な CSV エスケープルールに準拠します。

*   フィールド値に区切り文字 (標準では `,`)、ダブルクォート (`"`)、または改行コード (`\\n`, `\\r\\n`) が含まれる場合は、そのフィールド全体をダブルクォート (`"`) で囲む必要があります (MUST)。
*   フィールド値がダブルクォートで囲まれている場合、その内部に含まれるダブルクォート (`"`) は、2つの連続するダブルクォート (`""`) にエスケープする必要があります (MUST)。
*   **`array` および `object` 型の特殊な扱い:**
    *   これらの型の値は、まず対応する JSON 配列またはオブジェクトから JSON 文字列にシリアライズされます (MUST)。
    *   次に、生成された JSON 文字列が上記の CSV エスケープルールに従って処理されます (MUST)。
    *   **例 (JSON配列):**
        *   元の配列: `[1, "foo", true]`
        *   JSON 文字列化: `[1,"foo",true]`
        *   CSV セル内: `"[1,""foo"",true]"`
    *   **例 (JSONオブジェクト):**
        *   元のオブジェクト: `{"id": 10, "tag": "bar"}`
        *   JSON 文字列化: `{"id":10,"tag":"bar"}`
        *   CSV セル内: `"{""id"":10,""tag"":""bar""}"`

### 4.3. データ型と値の整合性

データ行の各フィールドの値は、ヘッダーで定義された型および非Null制約 (`!`) に準拠している必要があります (MUST)。

#### 4.3.1. 型不一致の判断基準 (例)

以下は、フィールドの値がヘッダーで定義された型と不一致であるとみなされる典型的なケースです（このリストは網羅的ではありません）。

*   `number` または `number!` 型のカラムに、数値として解釈できない非空文字列が存在する場合 (例: `"abc"`, `"N/A"`)。
*   `bool` または `bool!` 型のカラムに、パーサーがブール値 (推奨: `true`/`false`) として解釈できない非空文字列が存在する場合 (例: `"yes"`, `"不明"`)。
*   `date`/`datetime` または `date!`/`datetime!` 型のカラムに、パーサーが有効な日付/日時 (推奨: ISO 8601) として解釈できない非空文字列が存在する場合 (例: `"2023年1月1日"`, `"invalid date"`)。
*   `array`/`object` または `array!`/`object!` 型のカラムに、有効な JSON 文字列として解釈できない非空文字列が存在する場合 (例: `"[1,2,"`, `"{"key": "` )。

**注意:** カラムに非Null制約 (`!`) が **ない** 場合、空文字列 (`""`) は [4.1. NULL 値の表現](#41-null-値の表現) に従い `null` として解釈されるべきであり (SHOULD)、型不一致とはみなされません。

#### 4.3.2. 非Null制約違反

*   ヘッダーで非Null制約 (`!`) が指定されたカラム（例: `userId:number!`）に対応するデータ行フィールドが空 (`""`) である場合は、常に **制約違反** とみなされます (MUST)。

#### 4.3.3. 違反時の処理

CSVT パーサーは、型不一致または非Null制約違反を検出した場合の挙動を定義する必要があります。

*   **デフォルトの挙動 (推奨):**
    *   パーサーは、型不一致または非Null制約違反を検出した場合、デフォルトでエラーを報告し、パース処理を中断すべきです (SHOULD)。
    *   これにより、データの品質問題が早期に発見され、不正確なデータに基づく処理を防ぐことができます。
    *   報告されるエラー情報には、問題の特定に役立つ情報（例: 行番号、カラム名、期待される型、実際の値、エラー種別）を含むべきです (SHOULD)。
*   **オプションの挙動 (実装依存):**
    *   パーサーは、利用者の選択に応じて、以下の寛容な処理モードを提供してもよい (MAY):
        *   **エラー収集モード:**
            *   型不一致や制約違反が発生してもパース処理を中断せず、検出したすべてのエラー情報（行番号、カラム名、値、エラー種別などを含む）を収集します。
            *   パース完了後、部分的に成功したデータと収集されたエラーリストの両方を返します。
        *   **NULL 置換モード:**
            *   型不一致が発生したフィールドの値を `null` として扱います。
            *   **ただし、非Null制約 (`!`) が指定されたカラムで型不一致または空文字列が検出された場合は、このモードを選択していてもエラーとして処理しなければなりません (MUST)。**
            *   このモードは、データの一部に問題があっても処理を継続したい場合に有用ですが、意図しないデータ欠損が発生するリスクがあります。
*   **パーサーのドキュメント:**
    *   CSVT パーサーの実装者は、サポートするエラー処理モード、デフォルトの挙動、およびオプションの設定方法について、そのドキュメントで明確に記述する必要があります (MUST)。

## 5. セキュリティに関する考慮事項

信頼できないソースから提供された CSVT ファイルを処理する際には、潜在的なセキュリティリスクに注意が必要です。以下に主な考慮事項と推奨事項を示します。

*   **入力の検証:**
    *   ファイルの内容や構造が仕様に準拠しているかを確認するだけでなく、アプリケーションのコンテキストにおけるデータの妥当性（例: 文字列長、数値範囲、許可される文字など）も検証することが重要です。
*   **リソース消費:**
    *   非常に大きなファイル、極端に長い行、または多数のカラムを持つファイルは、パーサーのメモリや CPU リソースを過剰に消費する可能性があります (サービス拒否攻撃 - DoS)。可能な場合は、処理するファイルサイズや行数、カラム数に制限を設けることを検討してください。
*   **複合型 (`array`, `object`) のリスク:**
    *   これらの型は内部的に JSON 文字列をパースする必要があります。悪意を持って作成された JSON 文字列（例: 極端に深いネスト構造、非常に長い文字列）は、JSON パーサーのリソースを枯渇させ、DoS を引き起こす可能性があります。
    *   使用する JSON パーサーがこのような攻撃に対して耐性を持っているか、または設定可能な制限（最大ネスト深度、最大文字列長など）を提供しているかを確認し、適切に設定することを推奨します (SHOULD)。
    *   安全で、広く利用され、継続的にメンテナンスされている JSON ライブラリを使用してください (MUST)。
*   **インジェクションリスク:**
    *   CSVT ファイルから読み込んだデータ（特に `string` 型）を、HTML、SQL、コマンドラインなどの他のコンテキストで直接使用する場合、インジェクション攻撃（クロスサイトスクリプティング - XSS、SQL インジェクションなど）のリスクが生じる可能性があります。
    *   これは CSVT 特有の問題ではありませんが、データを他のシステムやコンポーネントに渡す前に、必ず適切なサニタイズまたはエスケープ処理を行う必要があります (MUST)。

CSVT パーサーの実装者は、これらのリスクを認識し、可能な限り安全なデフォルト設定を提供するとともに、利用者がセキュリティ関連の設定（リソース制限など）を調整できるオプションを提供することを検討すべきです (SHOULD)。

## Appendix A: CSVT ファイルの例

### A.1. 基本的な例

```csv
id:number!,name,registered:bool,created_at:date,last_login:datetime
1,"Alice",true,2023-01-15,2024-07-27T10:30:00Z
2,"Bob",false,2023-03-10,
3,"Charlie",true,2024-01-20,2024-07-26T15:00:00+09:00
```

*   `id` は非Null制約付きの数値型です。
*   `name` は型指定がないため `string` 型です。
*   `registered` はブーリアン型です。
*   `created_at` は日付型です。
*   `last_login` は日時型で、2行目はNULL値です。

### A.2. 複合型とエスケープを含む例

```csv
product_id:string!,tags:array,attributes:object,description:string
"P001","[""electronics"",""audio""]","{\""color\":\"black\",\"weight_kg\":1.5}","High-fidelity headphones, includes case."
"P002","[""books"",""fiction"",\"sci-fi\""","{\""pages\":350,\"author\":\"Jane Doe\"}","A novel about space travel"
"P003","[]","{}","Empty item, needs description."
"P004","[""gadget""]","{\""feature\":\"waterproof\"}","A device with a comma (,) and quotes (\"\")."
```

*   `tags` は `array` 型です。CSVセル内では JSON 文字列化され、内部のダブルクォートがエスケープされています。
*   `attributes` は `object` 型です。同様に JSON 文字列化と CSV エスケープが適用されています。
*   `description` は `string` 型です。4行目では、値にカンマ (`,`) とダブルクォート (`"`) が含まれるため、フィールド全体がダブルクォートで囲まれ、内部のダブルクォートが `""` にエスケープされています。
*   3行目は `tags` と `attributes` に空の配列/オブジェクトが指定されています。

### A.3. 非Null制約の例

```csv
user_id:number!,email:string!,is_active:bool!,score:number
101,"test@example.com",true,95
102,"another@example.com",false,
103,"",true,80  -- この行は email:string! 制約違反 (空文字列)
, "valid@example.com",true,75 -- この行は user_id:number! 制約違反 (空フィールド)
105,"final@example.com",,90    -- この行は is_active:bool! 制約違反 (空フィールド)
```

*   `user_id`, `email`, `is_active` には非Null制約 (`!`) が付いています。
*   3行目: `email` が空文字列 `""` のため、`email:string!` 制約違反です。
*   4行目: `user_id` が空フィールドのため、`user_id:number!` 制約違反です。
*   5行目: `is_active` が空フィールドのため、`is_active:bool!` 制約違反です。
*   `score` は `!` がないため、2行目のように空フィールド (NULL) が許容されます。

### A.4. 特殊文字を含むカラム名の例

```csv
"order:id":string!,"customer,name":string,value:number
"ORD-001","John Doe",150.00
"ORD-002","Smith, Jane",25.50
```

*   1番目のカラム名 `order:id` はコロン `:` を含むため、ダブルクォートで囲まれています。
*   2番目のカラム名 `customer,name` はカンマ `,` を含むため、ダブルクォートで囲まれています。 